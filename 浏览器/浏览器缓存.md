## 浏览器缓存

### 1、概述

浏览器缓存（Browser Caching）是浏览器将网络资源（html、js、css）存储在本地的一种行为。（浏览器将用户最近通过HTTP请求获取的资源存储在本地，当访问者再次访问同一页面时，浏览器就可以直接从本地加载资源）

也就是说浏览器缓存一般是缓存html、js、css等资源的，一般是get请求

浏览器缓存也可以叫HTTP缓存

http请求做为影响前端性能极为重要的一环，因为请求受网络影响很大，如果网络很慢的情况下,页面很可能会空白很久。对于**首次进入**网站的用户可能要通过优化接口性能和接口数量来解决。但是，对于**重复进入**页面的用户，除了浏览器缓存，http缓存可以很大程度对已经加载过的页面进行优化。

### 2、缓存的位置

从缓存位置上来看，分为4种，**从上往下依次检查是否命中**，如果都没有命中则重新发起请求。

![clipboard.png](assets/bVbwrBF.png)

- **Service Worker** 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。
- **Memory Cache** 是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
  - 目前Webkit（浏览器引擎）资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类：MainResourceLoader（主）和SubresourceLoader（派）。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。
- **Disk Cache** 是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。
  - 绝大部分的缓存都来自Disk Cache，在HTTP 的协议头中设置。
  - 它的直接操作对象为CurlCacheManager。
- **Push Cache**（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

**Memory Cache和Disk Cache的区别**

- 相同点：都只能存储一些派生类资源文件（css、脚本、html内嵌的图片）
- 不同点：
  - memory cache退出进程时数据会被清除，disk cache不会
  - memory cache一般存储脚本、字体、图片
  - disk cache一般存储非脚本，例如css
  - 因为CSS文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中,但是js之类的脚本却随时可能会执行,如果脚本在磁盘当中,我们在执行脚本的时候需要从磁盘取到内存中来,这样IO开销就很大了,有可能导致浏览器失去响应。

### 3、三级缓存原理（访问缓存优先级）

1. 先在内存中查找,如果有,直接加载。
2. 如果内存中不存在,则在硬盘中查找,如果有直接加载。
3. 如果硬盘中也没有,那么就进行网络请求。
4. 请求获取的资源缓存到硬盘和内存。

### 4、浏览器缓存的优点

- 减少了冗余的数据传输
- 减少了服务器的负担，提升了网站的性能
- 加快了客户端加载网页的速度

### 5、浏览器缓存的缺点

- 资源如果有更改但是客户端不及时更新会造成用户获取信息滞后

### 6、用户操作的影响

![clipboard.png](assets/bVbwrBs.png)

### 6、浏览器缓存的分类

强缓存和协商缓存。浏览器在向服务器请求资源时,首先判断是否命中强缓存,再判断是否命中协商缓存

浏览器在第一次访问接口后的response headers里会携带一些字段，这些字段决定关于这个请求的缓存情况

#### 1、**强缓存**

与强缓存相关的header字段有两个：expires 和 cache-control

浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息（服务端设置的，expires 和 cache-control）判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。

**Expires**（基本淘汰）

该字段是 **http1.0** 时的规范，它的值为一个**绝对时间**的 GMT 格式的时间字符串，比如 Expires: Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。

**Cache-Control**

Cache-Control 是 **http1.1** 时出现的 header 信息，主要是利用该字段的 **max-age** 值来进行判断，它是一个**相对时间**，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：

- **no-cache**（默认）：需要进行协商缓存，发送请求到服务器确认是否使用缓存。
- **no-store**：禁止使用缓存，每一次都要重新请求数据。
- **public**：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
- **private**：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。
- **immutable**：表示该资源永远不变，但是实际上该资源并不是永远不变，它这么设置的意思是为了让用户在刷新页面的时候不要去请求服务器。（如果不设置这个参数，当用户手动点击刷新页面时，即使符合缓存规则，浏览器也会直接去请求服务器）（强制刷新 ctrl+f5）

Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 **Cache-Control 优先级高**。

强缓存命中时，会直接从缓存中返回数据，状态码是200，会显示from disk(或 memory) cache。即浏览器没有跟服务器确认，直接用了浏览器缓存；







**关于缓存：第一次访问时，http返回的response header里会带有对应缓存的数据，cache-control、 Last-Modified、etag等，下一次请求时（强缓存没命中），会在request header里带上 if-none-matched、if-modified-since（也就是etag、Last-Modified）**

#### ①、强缓存

#### ②、协商缓存

当强缓存没有命中（例如超过设定的时间期限了）的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息（if-none-matched、if-modified-since）来判断是否命中缓存（资源是否修改）。如果命中（资源没修改），则返回 304（对应的header标识不变），告诉浏览器资源未更新，可使用本地的缓存。如果没命中（资源修改了），就返回新的数据，并更新对应的header的标识（etag、last-modified）

这里的 header 中的信息指的是 Last-Modified/If-Modified-Since 和 ETag/If-None-Match

Last-Modified、ETag是服务端设置在header里的，浏览器将其保存下来，当强缓存没命中，发请求到服务端时，request header里会带上这两个值，不过key会修改为if-none-matched、if-modified-since

**Last-Modified/If-Modified-Since**

浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modified，Last-modified 是一个时间标识该资源的最后修改时间。(精确到秒)

当浏览器再次请求该资源时，request 的请求头中会包含 If-Modified-Since，该值为之前返回的 Last-Modified。服务器收到 If-Modified-Since 后，根据资源的最后修改时间判断是否命中缓存（资源无更新即命中）。

如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modified。

缺点:

- 短时间内资源发生了改变，Last-Modified 并不会发生变化。（修改判定时间只能精确到秒）
- 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为,因此便有了 ETag。

**ETag/If-None-Match**

与 Last-Modified/If-Modified-Since 不同的是，Etag/If-None-Match 返回的是一个校验码（每个文件有一个，改动文件了就变了，可以看似md5）。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器请求的 If-None-Match 值来判断是否命中缓存。

与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。

etag是新增的，主要是为了解决几个last-modified比较难解决的问题：

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新get
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，if-modified-since能检查到的粒度是秒级的，这种修改无法判断
- 某些服务器不能精确的得到文件的最后修改时间

Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，然后才会继续比对 Last-Modified，最后才决定是否返回 304。？？？？？？？？？？？？？？？？？？？？？继续比对last不就与上文相悖了

#### ③、总结

当浏览器再次访问一个已经访问过的资源时，它会这样做：

- 看看是否命中强缓存，如果命中，就直接使用缓存了。
- 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。
- 如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。
- 否则，返回最新的资源。（返回200状态码，客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。）

