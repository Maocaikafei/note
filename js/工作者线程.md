前端开发者常说：“JavaScript 是单线程的。”这种说法虽然有些简单，但描述了 JavaScript 在浏览器中的一般行为。

**JavaScript 的单线程可以保证它与不同浏览器 API 兼容。**

而这也正是工作者线程的价值所在：**允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型**。虽然本章要介绍的各种工作者线程有不同的形式和功能，但它们的共同的特点是都**独立于 JavaScript 的主执行环境。**

## 工作者线程简介

JavaScript 环境实际上是运行在托管操作系统中的虚拟环境。**在浏览器中每打开一个页面，就会分配一个它自己的环境**。这样，每个页面都有自己的内存、事件循环、DOM，等等。**每个页面就相当于一个沙盒，不会干扰其他页面。**对于浏览器来说，同时管理多个环境是非常简单的，因为所有这些环境 都是并行执行的。

使用工作者线程，**浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境。这个子环境不能与依赖单线程交互的 API（如 DOM）互操作，但可以与父环境并行执行代码**

### 工作者线程与线程的差异

- 工作者线程是以实际线程实现的。例如，Blink 浏览器引擎实现工作者线程的 WorkerThread 就 对应着底层的线程
-  工作者线程并行执行。虽然页面和工作者线程都是单线程 JavaScript 环境，每个环境中的指令则可以并行执行。
- 工作者线程可以共享某些内存。工作者线程能够使用 SharedArrayBuffer 在多个环境间共享 内容。虽然线程会使用锁实现并发控制，但 JavaScript 使用 Atomics 接口实现并发控制
- 工作者线程不共享全部内存。在传统线程模型中，多线程有能力读写共享内存空间。除了 SharedArrayBuffer 外，从工作者线程进出的数据需要复制
- 工作者线程不一定在同一个进程里。通常，一个进程可以在内部产生多个线程。根据浏览器引 擎的实现，工作者线程可能与页面属于同一进程，也可能不属于。例如，Chrome 的 Blink 引擎对 共享工作者线程和服务工作者线程使用独立的进程。
- 创建工作者线程的开销更大。工作者线程有自己独立的事件循环、全局对象、事件处理程序和 其他 JavaScript 环境必需的特性。创建这些结构的代价不容忽视

`工作者线程相对比较重，不建议大量使用。例如，对一张 400 万像素的图片，为每个像素 都启动一个工作者线程是不合适的。通常，工作者线程应该是长期运行的，启动成本比较高， 每个实例占用的内存也比较大。`

### 工作者线程的类型

#### 专用工作者线程

通常简称为工作者线程、Web Worker 或 Worker，可以让脚本**单独创建一个 JavaScript 线程，以执行委托的任务。只能被创建它的页面使用**。

#### 共享工作者线程

共享工作者线程与专用工作者线程的主要区别，**是共享工作者线程可以被多个不同的上下文使用，包括不同的页面。**任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息。

#### 服务工作者线程

服务工作者线程与专用工作者线程和共享工作者线程截然不同。它的主要用途是拦截、重定向和修 改页面发出的请求，充当网络请求的仲裁者的角色

### WorkerGlobalScope