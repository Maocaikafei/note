**贪心算法：**具体什么样的问题用什么贪心策略是不确定的，贪心算法不能获得最优解，只是近似。必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。

**分治算法：**把问题拆成小问题，把小问题的解拼起来。（把数组切断，分段排序，然后再拼接）分解：将原问题分解成一系列子问题；解决：递归地求解各个子问题，若子问题足够小，则直接求解；合并：将子问题的结果合并成原问题。分治算法跟动态规划的明显区别：原问题分解成的子问题可以独立求解，子问题之间没有相关性

**动态规划：** 也是把问题拆成小问题，不过因为很多小问题会互相包含，导致重复计算，（这里是因为动态规划满足三种特性，分别是**最优子结构，无后效性，重复子问题，**我这里指的重复计算就是重复子问题）所以把小问题的解先保存起来，以便重复利用。重点：自底向上**状态转移方程是解决动态规划的关键****动态规划一共有两种解法思路，分别是1.回溯加记录表，记录下各个环节的值，避免重复计算。 2.通过找到状态转移方程加上记录表来解决**最长公共子序列，不需要连续。。1.**最优子结构**指的是，问题的最优解包含子问题的最优解。反过来说就是**可以通过子问题的最优解，推导出问题的最优解**。2. **无后效性**指某阶段状态一旦确定，就不受之后阶段的决策影响。3. **重复子问题是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

**回溯法：**回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，有时候只需求出一个解就行了，比如八皇后有时候需要列出所有可能性，例如01背包回溯法支持剪枝： 用约束函数在扩展结点处剪去不满足约束的子树；用限界函数剪去得不到最优解的子树。

**分支限界法：**求解目标：分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。搜索方式：以广度优先或以最小耗费优先的方式搜索解空间树。分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。

**四种算法思想比较分析：贪心、分治、回溯和动态规划。**     如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。     回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。     尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。     在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为其算法实现中存在大量的重复子问题。     贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。

# 分治算法

分而治之，把一个复杂的问题分成多个相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并

由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。**反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生**



## **分治法适用的情况**

   分治法所能解决的问题一般具有以下几个特征：

  1) 该问题的规模缩小到一定的程度就可以容易地解决

  2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

  3) 利用该问题分解出的子问题的解可以合并为该问题的解；

  4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。

第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；

**第二条特征是应用分治法的前提**它也是大多数问题可以满足的，此特征反映了递归思想的应用；

**第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征**，如果**具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法**。

**第四条特征涉及到分治法的效率**，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但**一般用动态规划法较好**。

## 分治法基本步骤

 step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题

 step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

 step3 合并：将各个子问题的解合并为原问题的解

# 动态规划

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，**前一子问题的解，为后一子问题的求解提供了有用的信息**。在求解任一子问题时，**列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。**依次解决各子问题，最后一个子问题就是初始问题的解。

   由于**动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次**，将其不同阶段的不同状态保存在一个二维数组中。

   与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的**子问题往往不是互相独立的**（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。

## 适用情况

 (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

 (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

## 基本步骤

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。**这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线**(通常是求最优的活动路线)

## 关键点

使用动态规划求解问题，最重要的就是确定动态规划三要素：

   （1）问题的阶段 （2）每个阶段的状态

   （3）从前一个阶段转化到后一个阶段之间的递推关系

## leetcode

53

# 贪心算法

  所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，**不从整体最优上加以考虑**，他所做出的仅是在某种意义上的**局部最优解**。

  算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备**无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。**

## 基本思路

1.建立数学模型来描述问题。

2.把求解的问题分成若干个子问题。

3.对每一子问题求解，得到子问题的局部最优解。

4.把子问题的解局部最优解合成原来解问题的一个解

## 适用情况

满足贪心选择性质 和 最优子结构性质 

贪心选择性质：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。

对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解



当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。**问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征**

## 例题

[背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。

  要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。

  物品 A B C D E F G

  重量 35 30 60 50 40 10 25

  价值 10 40 30 50 35 40 30

  分析：

  目标函数： ∑pi最大

  约束条件是装入的物品总重量不超过背包容量：∑wi<=M( M=150)

  （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？

  （2）每次挑选所占重量最小的物品装入是否能得到最优解？

  （3）每次选取单位重量价值最大的物品，成为解本题的策略。

  值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。

  贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。

  **可惜的是，它需要证明后才能真正运用到题目的算法中。**

  一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。

  对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：

  （1）贪心策略：选取价值最大者。反例：

  W=30

  物品：A B C

  重量：28 12 12

  价值：30 20 20

  根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。

  （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。

  （3）贪心策略：选取单位重量价值最大的物品。反例：

  W=30

  物品：A B C

  重量：28 20 10

  价值：28 20 10

  根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。但是如果在条件中加一句当遇见单位价值相同的时候,优先装重量小的,这样的问题就可以解决