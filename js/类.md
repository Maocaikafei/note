class 关键字具有正式定义类的能力，是ECMAScript 6 新引入的

是一种基础性语法糖结构，表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念

## 一、类定义

1、定义类有两种主要方式：类声明和类表达式

```js
// 类声明
class Person {} 
// 类表达式
const Animal = class {}; 
```

2、类表达式可以提升，类声明不能

```js
console.log(ClassExpression); // undefined 
var ClassExpression = class {}; 
console.log(ClassExpression); // class {} 

console.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not defined 
class ClassDeclaration {} 
console.log(ClassDeclaration); // class ClassDeclaration {}
```

3、函数受函数作用域限制，而类受块作用域限制

```js
{ 
 function FunctionDeclaration() {} 
 class ClassDeclaration {} 
} 
console.log(FunctionDeclaration); // FunctionDeclaration() {} 
console.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not defined
```

### 类的构成

类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。 **空的类定义照样有效**。

## 二、类构造函数

constructor 关键字用于在类定义块内部创建类的构造函数。

方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。

构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。

### 1、实例化

使用 new 调用类的构造函数会执行如下操作。 

1. 在内存中创建一个新对象。
2. 这个新对象内部的[[Prototype]]指针被赋值为构造函数的 prototype 属性。
3. 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。
4. 执行构造函数内部的代码（给新对象添加属性）。
5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象

### 2、构造函数的返回值

默认情况下，类构造函数会在执行之后返回 this 对象。

构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 this 对象，那么这个对象会被销毁。

**如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改**

```js
class Person { 
 constructor(override) { 
 this.foo = 'foo'; 
 if (override) { 
 return { bar: 'bar' }; 
 } } } 
let p1 = new Person(), p2 = new Person(true); 
console.log(p1); // Person{ foo: 'foo' } 
console.log(p1 instanceof Person); // true 
console.log(p2); // { bar: 'bar' } 
console.log(p2 instanceof Person); // false 
```

### 3、类构造函数与构造函数的主要区别

调用类构造函数必须使用 new---作符，否则会会抛出错误。

普通构造函数如果不使用 new 调用，那么就会以全局的 this（通常是 window）作为内部对象。

**这里的构造函数是脱离于类独自存在的，不同于java等语言中常说的构造函数**

## 三、类是一种特殊函数

ECMAScript 中没有正式的类这个类型。从各方面来看，ECMAScript 类就是一种特殊函数。声明一个类之后，**通过 typeof 操作符检测类标识符，表明它是一个函数**

```js
class Person {} 
console.log(Person); // class Person {} 
console.log(typeof Person); // function 
```

类标识符有 prototype 属性，而这**个原型也有一个 constructor 属性指向类自身**：

```js
class Person{} 
console.log(Person.prototype); // { constructor: f() } 
console.log(Person === Person.prototype.constructor); // true
```

如前所述，类本身具有与普通构造函数一样的行为。在类的上下文中，类本身在使用 new 调用时就 会被当成构造函数。重点在于，**类中定义的 constructor 方法不会被当成构造函数**，在对它使用 instanceof 操作符时会返回 false。

```js
class Person {} 
let p1 = new Person(); 
console.log(p1.constructor === Person); // true 
console.log(p1 instanceof Person); // true 
console.log(p1 instanceof Person.constructor); // false 
```

### 类可以像其他对象或函数引用一样作为参数传递

```js
// 类可以像函数一样在任何地方定义，比如在数组中
let classList = [ 
 class { 
 constructor(id) { 
 this.id_ = id; 
 console.log(`instance ${this.id_}`); 
 } 
 } 
]; 
function createInstance(classDefinition, id) { 
 return new classDefinition(id); 
} 
let foo = createInstance(classList[0], 3141); // instance 3141 
```

## 四、实例、原型和类成员

### 1、实例属性

在类构造函数内部，可以为新创建的实例（this） 添加“自有”属性。**在构造函数执行完毕后，仍然可以给实例继续添加新属性**。

每个实例都对应一个唯一的对象，这意味着**所有属性都不会在原型上共享**

### 2、原型方法与访问器

为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。

**在类块中定义的所有内容都会定义在类的原型上**

```js
class Person { 
 constructor() { 
 // 添加到 this 的所有内容都会存在于不同的实例上
 this.locate = () => console.log('instance'); 
 } 
 // 在类块中定义的所有内容都会定义在类的原型上
 locate() { 
 console.log('prototype'); 
 } 
} 
let p = new Person(); 
p.locate(); // instance 
Person.prototype.locate(); // prototype
console.log(p.__proto__.locate()) // prototype
```

**不能在类块中给原型添加原始值或对象作为成员数据**

```js
class Person { 
 name: 'Jake' 
} 
// Uncaught SyntaxError: Unexpected token
```

类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键

```js
class Person { 
 ['computed' + 'Key']() { 
 console.log('invoked computedKey'); 
 } 
} 
let p = new Person(); 
p.computedKey(); // invoked computedKey
```

**类定义也支持获取和设置访问器**。语法与行为跟普通对象一样

```js
class Person { 
 set name(newName) { 
 this.name_ = newName; 
 } 
 get name() { 
 return this.name_; 
 } 
} 
let p = new Person(); 
p.name = 'Jake'; 
console.log(p.name); // Jake
```

### 3、静态类方法

可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，**静态方法是共享的**，静态方法不保存在原型上

静态类成员在类定义中使用 static 关键字作为前缀。在静态成员中，this 引用类自身。其他所有约定跟原型成员一样

```js
class Person { 
 constructor() { 
 // 添加到 this 的所有内容都会存在于不同的实例上
 this.locate = () => console.log('instance', this); 
 } 
 // 定义在类的原型对象上
 locate() { 
 console.log('prototype', this); 
 } 
 // 定义在类本身上
 static locate() { 
 console.log('class', this); 
 } 
} 
let p = new Person(); 
p.locate(); // instance, Person {} 
Person.prototype.locate(); // prototype, {constructor: ... } 
Person.locate(); // class, class Person {}
```

### 4、非函数原型和类成员

**虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加**。**而且是加在类上，而非实例上**

```js
class Person { 
 sayName() { 
 console.log(`${Person.greeting} ${this.name}`); 
 } 
} 

// 在类上定义数据成员
Person.greeting = 'My name is';

// 在原型上定义数据成员
Person.prototype.name = 'Jake'; 
let p = new Person(); // 这里就算是先实例化，即移到第6行，结果也一样
p.sayName(); // My name is Jake
```

