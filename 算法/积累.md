## 二叉树的中序遍历

迭代解法：

1. 使用一个栈来存储已遍历的节点，使用一个resList数组存储最终结果
2. 从根节点开始，一直往左节点移动，将遍历到的节点入栈，直到底部，这时候就走到了整棵树的最左下方，将其置入resList
3. 接下来，开始倒车，一个一个地从栈中取出节点，并置入resList（相当于取出上一个处理的节点的父节点）
4. 将指针移到当前节点的右节点，同时并开始下一个循环
5. 如果这个右节点有值，那就相当于执行第二步（将这个右节点视作根节点）
6. 如果右节点没值，那就可以继续出栈了

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    if (root === null) {
        return [];
    }
    const res = [];
    const stack = [];
    let node = root;
    while (node || stack.length > 0) { 
        while(node) { 
            stack.push(node);
            node = node.left;
        }
        // 遍历左节点直到尽头，出栈就是‘左节点、父节点、父节点、父节点...’顺序，此时再看每个出栈元素的右节点
        node = stack.pop();
        res.push(node.val);

        node = node.right; // 很重要，这里无论存不存在right，都要移动指针，防止倒车时又重新遍历出栈节点的左子树
    } 
    return res;
};
```

## 二叉树的先序遍历

迭代解法：

思路很简单，准备一个栈和一个resList

将想要输出的元素按照逆序入栈即可

1. 将根节点入栈，开始循环
2. 出栈，置入resList，如果存在右节点，右节点入栈，如果存在左节点，左节点也入栈
3. 开始第二轮循环，出栈，此时就是上一个节点的左元素，置入resList
4. 对于这个元素，如果存在右节点，右节点入栈，如果存在左节点，左节点也入栈
5. 如此循环往复

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (!root) {
        return [];
    }
    const res = [];
    let node = root;
    const stack = [node];
    while (stack.length > 0) {
        node = stack.pop();
        res.push(node.val);

        if (node.right) {
            stack.push(node.right);
        }
        if (node.left) {
            stack.push(node.left);
        }
    }
    return res;
};
```

## 二叉树的后序遍历

迭代解法：

简略思路：将先序遍历的中左右改成中右左，即先压入右子树再压入左子树，然后将所得的数组逆序排列，即是答案

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if (!root) {
        return [];
    }
    const res = [];
    const stack = [root];
    let node = root;
    while (stack.length > 0) {
        node = stack.pop();
        res.push(node.val);

        if(node.left) {
            stack.push(node.left);
        }
        if(node.right) {
            stack.push(node.right);
        }
    }
    return res.reverse();
};
```

## 二叉树三种遍历统一解法

可看leetcode后序遍历的评论

## 两数相加

![image-20220529195506990](assets/image-20220529195506990.png)

解题思路：

不能转为数字，因为可能会溢出

将两个链表从头开始，每两个节点相加，进位数保留到下两个节点一起相加，短的链表不够加时补0，边计算边获取结果

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let add = 0;
    let res;
    let node;
    let tempSum;
    let sum;
    while(l1 || l2 || add !== 0) {
        val1 = l1?.val ?? 0;
        val2 = l2?.val ?? 0;
        tempSum = Number(val1) + Number(val2) + Number(add);
        sum = tempSum % 10;
        
        if (tempSum >= 10) {
            add = String(tempSum)[0];
        } else {
            add = 0;
        }

        if (res === undefined) {
            res = new ListNode(sum);
            node = res;
        } else {
            node.next = new ListNode(sum);
            node = node.next;
        }
        l1 = l1?.next;
        l2 = l2?.next;
    }
    return res;
};
```

## 无重复字符的最长子串

![image-20220529233124739](assets/image-20220529233124739.png)

解题思路：

创建一个list，逐字符遍历字符串s，对遍历到的字符char进行判断，如果list包含char，就**获取list中重复的char在s中的index，截取s从index + 1到当前字符char的内容作为list**，同时判断是否为最长。如果不包含，就将char置入list。

```js
var lengthOfLongestSubstring = function(s) {
    let list = '';
    let res = 0;
    for (let i = 0; i < s.length; i += 1) {
        if (!list.includes(s[i])) {
            list = `${list}${s[i]}`;
        } else {
            const index = s.slice(0, i).lastIndexOf(s[i]);
            list = s.slice(index + 1, i + 1);
        }
        if (list.length > res) {
            res = list.length;
        }
    }
    return res;
};
```

这里比较复杂的地方就是加粗部分了。

评论题解都提到了滑动窗口，用双指针实现，这确实更优雅。每次右指针左移一格，就判定两个指针直接是否有重复元素，有的话，就将左指针移动到重复元素之后，并计算两指针之间字串长度

```js
var lengthOfLongestSubstring = function(s) {
    if (s.length === 1) {
        return 1;
    }
    let res = 0;
    for (let i = 1, j = 0; i < s.length; i += 1) {
        const index = s.slice(j, i).indexOf(s[i]);
        if (index !== -1) {
            j = j + index + 1;
        }
        res = (i - j + 1) > res ? i - j + 1 : res;
    }
    return res;
};
```

