ECMAScript 有 **6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、 String 和 Symbol**。Symbol（符号）是 ECMAScript 6 新增的。还**有一种复杂数据类型叫 Object（对 象）**。**Object 是一种无序名值对的集合**。

### typeof 操作符

可确定任意变量的数据类型

对一个值使用 typeof 操作符会返回下列字符串之一：

- "undefined"表示值未定义
- "boolean"表示值为布尔值
- "string"表示值为字符串
- "number"表示值为数值
- "object"表示值**为对象（而不是函数）或 null**（特殊值 null 被认为是一个对空对象的引用）
- "function"表示值为函数
- "symbol"表示值为符号

严格来讲，**函数在 ECMAScript 中被认为是对象，并不代表一种数据类型**。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象

#### Undefined 类型

Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值

**对未声明的变量**，只能执行一个有用的操作，就是对它调用 typeof，返回的结果是"undefined”

#### Null 类型

逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回"object"的原因

在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查 这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用

**任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量**。这样就可以保持 null 是空对象指针的语义，并进一步将其 与 undefined 区分开来

`console.log(null == undefined); // true `

#### Boolean 类型

布尔值不同于数值，因此 true 不等于 1，false 不等于 0。（**但可以使用Number()函数转换为数值，true为1，false为0**）

虽然布尔值只有两个，但**所有其他 ECMAScript 类型的值都有相应布尔值的等价形式**。要将一个其他类型的值转换为布尔值，可以调用特定的 **Boolean()**转型函数

Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。

![image-20220404163551813](assets/image-20220404163551813.png)

**像 if 等流控制语句会自动执行其他类型值到布尔值的转换**

#### Number 类型

####  浮点值

要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然**小数点前面不是必须有整数**，但推荐加上。

（`const a = 1.`  是合法的，不过会被自动转换为整数1）

因为**存储浮点值使用的内存空间是存储整数值的两倍**，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，**如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数**

```js
let floatNum1 = .1; // 有效，但不推荐
let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理

// console.log: 0.1, 1，10
```

**永远不要测试某个特定的浮点值**

浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不 是 0.3，而是 0.300 000 000 000 000 04

```js
if (a + b == 0.3) { // 别这么干！ 
 console.log("You got 0.3."); 
} 
```

#### 值的范围

如果某个计算得到的 数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无 穷）值。任何无法表示的负数以`-Infinity`（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示。

要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 isFinite()函数

#### NaN

有一个特殊的数值叫 NaN，意思是“不是数值”（**Not a Number**），用于表示本来**要返回数值的操作失败了（而不是抛出错误）**。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执 行。但在 ECMAScript 中，0、+0 或-0 相除会返回 NaN

```js
console.log(0/0); // NaN 
console.log(-0/+0); // NaN
// 如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity：
console.log(5/0); // Infinity 
console.log(5/-0); // -Infinity 
```

NaN 有几个独特的属性

1、**任何涉及 NaN 的操作始终返回 NaN**（如 NaN/10），在连续多步计算时这可能是个问题

2、**NaN 不等于包括 NaN 在内的任何值**。

`console.log(NaN == NaN); // false `

为此，ECMAScript 提供了**isNaN()**函数。该函数接收一个参数，可以是任意数据类型，然后判断 这个参数是否“不是数值”

**把一个值传给 isNaN()后，该函数会尝试把它转换为数值**。某些非数值的 值可以直接转换成数值，如字符串"10"或布尔值。**任何不能转换为数值的值都会导致这个函数返回 true。**

```js
console.log(isNaN(NaN)); // true 
console.log(isNaN(10)); // false，10 是数值
console.log(isNaN("10")); // false，可以转换为数值 10 
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值 1 
```

#### 数值转换

有 3 个函数可以将非数值转换为数值：**Number()、parseInt()和 parseFloat()**。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。

Number()函数基于如下规则执行转换

- 布尔值，true 转换为 1，false 转换为 0

- 数值，直接返回

- **null，返回 0**

- **undefined，返回 NaN**

  

在需要得到整数时可以优先使 用 **parseInt()**函数，parseInt()函数更专注于字符串是否包含数值模式

字符串最前面的空格会被 忽略从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即 返回 NaN。这意味着空字符串也会返回 NaN（这一点跟 Number()不一样，它返回 0）。如果第一个字符 是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如， "1234blue"会被转换为 1234，因为"blue"会被完全忽略。类似地，"22.5"会被转换为 22，因为小数 点不是有效的整数字符

``console.log(parseInt("  123aa123")) // 123``

不同的数值格式很容易混淆，因此 parseInt()也接收第二个参数，用于指定底数（进制数）。如 果知道要解析的值是十六进制，那么可以传入 16 作为第二个参数，以便正确解析。因为不传底数参数相当于让 parseInt()自己决定如何解析，所以为避免解析出错，**建议始终传给它第二个参数**。

**parseFloat()**函数的工作方式跟 parseInt()函数类似，都是从位置 0 开始检测每个字符。同样， 它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。**这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了**，此时字符串的剩余字符都会被忽略。因此，"22.34.5"将转换 成 22.34

parseFloat()只解析十进制值，因此不能指定底数

### String 类型

字符串可以使用双引号（"）、 单引号（'）或反引号（`）标示。引号没有区别。不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾

字符串数据类型包含一些字符字面量，如 `\n 换行，\r 回车`。这些字符字面量可以出现在字符串中的任意位置，且**可以作为单个字符被解释**

`let text = "sigma: \u03a3.";`

`console.log(text.length); // 8 `

在这个例子中，**即使包含 6 个字符长的转义序列，变量 text 仍然是 8 个字符长。因为转义序列表 示一个字符，所以只算一个字符**

#### 字符串的特点

ECMAScript 中的字符串是**不可变的（immutable）**，意思是一旦创建，它们的值就不能变了。**要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量**

```js
let lang = "Java"; 
lang = lang + "Script";
```

这里，变量 lang 一开始包含字符串"Java"。紧接着，lang 被重新定义为包含"Java"和"Script" 的组合，也就是"JavaScript"。**整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上 "Java"和"Script"。最后销毁原始的字符串"Java"和字符串"Script"，因为这两个字符串都没有用了**。

#### 转换为字符串

有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 **toString()**方法。这个方法唯一的用途就是返回当前值的字符串等价物

`let foundAsString = found.toString(); // 字符串"true" `

toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 toString()方法， 该方法只是简单地返回自身的一个副本。）**null 和 undefined 值没有 toString()方法。**

多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可接收一个底数参数，即以什么底数来输出数值的字符串表示。**默认情况下，toString()返回数值的十进制字符串表示**。而通过传入参数，可以得到数值的二进制、八进制、十六进制

**如果你不确定一个值是不是 null 或 undefined，可以使用 String()转型函数**，它始终会返回表 示相应类型值的字符串。

- 如果值有 toString()方法，则调用该方法（不传参数）并返回结果
- 如果值是 null，返回"null"
- 如果值是 undefined，返回"undefined"

用加号操作符给一个值加上一个空字符串""也可以将其转换为字符串

`console.log(typeof ("" + undefined)) // string`

#### 模板字面量

与使用单引号或双引号不同，模板字面量**保留换行字符**，可以跨行定义字符串

```js
let myMultiLineTemplateLiteral = `first line 
second line`; 

console.log(myMultiLineTemplateLiteral); 
// first line
// second line 

let myMultiLineString = 'first line\nsecond line'; 
console.log(myMultiLineString === myMultiLinetemplateLiteral); // true
```

#### 字符串插值

技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量**在定义时立即求值并转换为字符串实例**，任何插入的变量也会从它们最接近的作用域中取值

此外，**模板也可以插入自己之前的值**

```js
let value = ''; 
function append() { 
 value = `${value}abc` 
 console.log(value); 
} 
append(); // abc 
append(); // abcabc 
append(); // abcabcabc
```

### Symbol 类型

Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。 **符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险**

#### 符号的基本用法

符号需要使用 **Symbol()函数初始化**。因为符号本身是原始类型，所以 typeof 操作符对符号返回 symbol。

```js
let sym = Symbol(); 
console.log(typeof sym); // symbol 
```

调用 Symbol()函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是，**这个字符串参数与符号定义或标识完全无关**

符号没有字面量语法，这也是它们发挥作用的关键。按照规范，**你只要创建 Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性**

```js
let genericSymbol = Symbol(); 
console.log(genericSymbol); // Symbol() 
let fooSymbol = Symbol('foo'); 
console.log(fooSymbol); // Symbol(foo); 
```

最重要的是，Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，**像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原 始值的包装对象**

```js
let myBoolean = new Boolean(); 
console.log(typeof myBoolean); // "object" 
let myString = new String(); 
console.log(typeof myString); // "object" 
let myNumber = new Number(); 
console.log(typeof myNumber); // "object" 
let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
```

### Object 类型

ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称 来创建。

这个语法类似 Java，但 ECMAScript 只要求在给构造函数提供参数时使用括号。如果没有参数，如 上面的例子所示，那么完全可以省略括号（不推荐）

`let o = new Object; // 合法，但不推荐`

严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏 览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象 不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object